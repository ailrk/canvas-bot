import {Config} from './types';
import path from 'path';
import fs from 'fs';
import {notUndefined} from './utils';

export type Path = {readonly path: string}
export function mkPath(p: string): Path {
  return {
    path: path.resolve(p),
  };
}

// This is one of the major data structure for implementing new file only update,
// another one is FolderTree.
//
// To only update new files we don't have in local folder, we
// build two FolderTrees: one for files in the base directory and the other for
// files from canvas. Nodes of these two trees will have some common elements like
// filename and foldernames etc, but only canvas FolderTree will have url and id.
//
// Once we built this two trees, we can compare the differences, and mark nodes
// that doesn't exist in the local tree.
// Then we perform a data fetch based on the marked canvas folder tree.
//
// Two trees will be merged after files get download, and the result will be
// saved as snapshot.
interface Tagged {
  tag?: boolean;

  visited?: true;
}

export interface FileIdentity extends Tagged {
  readonly _kind: "FileIdentity",

  // generated by hashing the original name.
  // once it is changed it cannot be turned back.
  readonly id?: number,

  // folder tree build from local files will not have this field.
  // tree build form canvas api or stored in snapshot.
  readonly fileUrl?: string,

  // all files have a parent
  parentFolder: FolderTree,

  // filename.
  readonly filename: string,
}


// folder tree. It's used to represent the local folder structure
// Both FolderTree and FolderTreeLeaf countes as a node of the tree.
// Each node wlll have a tag to indicate if this node diffred from another tree.
//
// Two nodes are different if either
// 1. the node doesn't exist in another tree
//    (e.g. a common parent node cannot reach the current node with the same folder name)
// 2. the node contains different files.
//    (e.g A folder tree has a different )
export type FolderTree = {
  readonly _kind: "FolderTree",

  // full path of the folder
  // for canvas FolderTree each course will has the course name as
  // a corresponding folder name.
  // Thie field workds like _kind in a tag union, it marks the identity of a node.
  readonly folderName: string,

  // only root FolderTree has null
  parentFolder: FolderTree | null,

  // node values.
  files?: FileIdentity[],

  // node path.
  path?: FolderTree[],

} & Tagged;

export type Node = FolderTree | FileIdentity;

/**
 * Make folder tree of current base directory.
 * If the directory is full then use another one.
 */
export async function getLocalFolderTree(config: Config) {
  const {baseDir} = config;
  return traverseDir(baseDir);
}


export function mkParialRoot(config: Config): Partial<FolderTree> {
  console.log(config);
  return <Partial<FolderTree>>{
    _kind: "FolderTree",
    folderName: config.baseDir.path,
    parentFolder: null,
  }
}

/**
 * @param folderName path of a directory.
 * @return A folder tree represent the structure of the   directory.
 *         The FolderTree will also be generate for files come from canvas.
 *         These two tree will be compared and perform new file only update.
 */

// @rec
async function traverseDir(folderName: Path): Promise<FolderTree> {return traverseDir_(folderName);}
export function traverseDir_(folderName: Path): FolderTree {

  const path = folderName.path;

  // all names under the folder (all full paths)
  const names = fs.readdirSync(path).map(e => `${path}/${e}`);

  const folders: string[] = names
    .filter(e => {
      return fs.lstatSync(e).isDirectory();
    });

  const files: string[] = names
    .filter(e => fs.lstatSync(e).isFile());

  // @base case. no folder any more
  if (folders.length === 0) {
    const thisTree: Partial<FolderTree> = {
      _kind: "FolderTree",
      folderName: path,
      parentFolder: null,
    };
    thisTree.files = files.map(e => <FileIdentity>{
      filename: e,
      parentFolder: thisTree,
    });
    return <FolderTree>thisTree;
  };

  // @inductive steps
  const thisTree: Partial<FolderTree> = {
    _kind: "FolderTree",
    folderName: path,
    parentFolder: null,
  };
  thisTree.files = files.map(e => <FileIdentity>{
    _kind: "FileIdentity",
    filename: e,
    parentFolder: thisTree,
  });
  thisTree.path = folders.map(e => <FolderTree>{
    ...traverseDir_(mkPath(e)),
    _kind: "FolderTree",
    parentFolder: thisTree,
  })
  return <FolderTree>thisTree;
}


/**
 * Diff two tree, return a pair of marked trees.
 *
 * Turn both trees into list, mark everything in the from list.
 * Rebuild a new tree with all nodes contained. If there is a duplicate node, use
 * the marked version.
 * Two nodes are duplicated if they have the same (filename / foldername)
 *
 * @param a FolderTree.
 * @param a FolderTree.
 * @return A tree with nodes of both trees. If a node is marked means it exists only
 *         in the from tree but not on to tree.
 */
function folderTreeDiff(from: FolderTree, to: FolderTree) {

  const {a, b, reason} = markNodeDiff_(from, to);

  switch (reason) {
    case "same":
      break

    case "differentFile":
      //
      break

    case "differentFolder":
      //
      break
  }
}

/**
 * Check if two nodes are the same. If not, is because of different path
 * or different file they contains.
 * Note If two nodes are different, then even their files are the same they will
 * still be marked different.
 * @return Input FoldTree with different nodes being marked, plus the reason why it's marked.
 *
 */
function markNodeDiff(a: FolderTree, b: FolderTree): {
  a: FolderTree,
  b: FolderTree,
  reason: "differentFile" | "differentFolder" | "same"
} {

  const afilenames = a.files?.map(e => e.filename).sort();
  const bfilenames = b.files?.map(e => e.filename).sort();

  // mark node. If two node are different then all there subtree
  // and files they contain are different.
  if (a.folderName !== b.folderName) {
    return {
      a: {...a, tag: true},
      b: {...b, tag: true},
      reason: "differentFolder"
    };
  }

  // mark files
  if (afilenames === undefined || bfilenames === undefined) {
    // all files are different
    return {
      a: {
        ...a,
        files: a.files ? a.files.map(e => ({...e, tag: true})) : undefined,
      },

      b: {
        ...b,
        files: b.files ? b.files.map(e => ({...e, tag: true})) : undefined,
      },

      reason: "differentFile",
    }
  }

  // find and mark set difference between two list of FileIdentity,
  const seta = new Set(afilenames);
  const setb = new Set(bfilenames);
  const notIna = new Set([...bfilenames].filter(e => !seta.has(e)))
  const notInb = new Set([...afilenames].filter(e => !setb.has(e)));

  if (notIna.size + notInb.size > 0) {
    return {
      a: {
        ...a,
        files: a.files?.filter(e => notInb.has(e.filename))
          .map(e => ({...e, tag: true}))
      },
      b: {
        ...b,
        files: b.files?.filter(e => notInb.has(e.filename))
          .map(e => ({...e, tag: true}))
      },
      reason: "differentFile"
    }
  }

  // exactly the same node.
  return {a, b, reason: "same"};
}


/**
 * FolderTree visitor. Visitor every node of the tree and perform some operation on it.
 * @param node a tree node. Normally a root.
 * @param f action perform on the node, return the new node for the rest ofthe traversal.
 */
export function folderTreeVisitor(node: FolderTree, f: (node: Node) => void): FolderTree {
  const nodeCopy = {...node};

  folderTreeVisitor_(nodeCopy, f);
  return nodeCopy;
}
export function folderTreeVisitor_(
  node: Node,
  f: (node: Node) => void) {

  // mutate the node
  f(node);

  node.visited = true;

  if (node._kind === "FolderTree") {
    const edges = [...node.path ?? [], ...node.files ?? []];
    edges.forEach(e => {
      if (!e.visited) {
        folderTreeVisitor_(e, f);
      }
    })
  }
}
