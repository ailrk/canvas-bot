import {Config} from './types';
import path from 'path';
import fs from 'fs';
import {notUndefined} from './utils';

export type Path = {readonly path: string}
export function mkPath(p: string): Path {
  return {
    path: path.resolve(p),
  };
}

// This is one of the major data structure for implementing new file only update,
// another one is FolderTree.
//
// To only update new files we don't have in local folder, we
// build two FolderTrees: one for files in the base directory and the other for
// files from canvas. Nodes of these two trees will have some common elements like
// filename and foldernames etc, but only canvas FolderTree will have url and id.
//
// Once we built this two trees, we can compare the differences, and mark nodes
// that doesn't exist in the local tree.
// Then we perform a data fetch based on the marked canvas folder tree.
//
// Two trees will be merged after files get download, and the result will be
// saved as snapshot.
interface Tagged {
  tag?: boolean;

  visited?: true;
}

export interface FileIdentity extends Tagged {
  readonly _kind: "FileIdentity",

  // generated by hashing the original name.
  // once it is changed it cannot be turned back.
  readonly id?: number,

  // folder tree build from local files will not have this field.
  // tree build form canvas api or stored in snapshot.
  readonly fileUrl?: string,

  // all files have a parent
  parentFolder: FolderTree,

  // filename.
  readonly filename: string,
}


// folder tree. It's used to represent the local folder structure
// Both FolderTree and FolderTreeLeaf countes as a node of the tree.
// Each node wlll have a tag to indicate if this node diffred from another tree.
//
// Two nodes are different if either
// 1. the node doesn't exist in another tree
//    (e.g. a common parent node cannot reach the current node with the same folder name)
// 2. the node contains different files.
//    (e.g A folder tree has a different )
export type FolderTree = {
  readonly _kind: "FolderTree",

  // full path of the folder
  // for canvas FolderTree each course will has the course name as
  // a corresponding folder name.
  // Thie field workds like _kind in a tag union, it marks the identity of a node.
  readonly folderName: string,

  // only root FolderTree has null
  parentFolder: FolderTree | null,

  // node values.
  files?: FileIdentity[],

  // node path.
  path?: FolderTree[],

} & Tagged;

export type Node = FolderTree | FileIdentity;

/**
 * Make folder tree of current base directory.
 * If the directory is full then use another one.
 */
export async function getLocalFolderTree(config: Config) {
  const {baseDir} = config;
  return traverseDir(baseDir);
}


export function mkParialRoot(config: Config): Partial<FolderTree> {
  console.log(config);
  return <Partial<FolderTree>>{
    _kind: "FolderTree",
    folderName: config.baseDir.path,
    parentFolder: null,
  }
}

/**
 * @param folderName path of a directory.
 * @return A folder tree represent the structure of the   directory.
 *         The FolderTree will also be generate for files come from canvas.
 *         These two tree will be compared and perform new file only update.
 */

// @rec
async function traverseDir(folderName: Path): Promise<FolderTree> {return traverseDir_(folderName);}
export function traverseDir_(folderName: Path): FolderTree {

  const path = folderName.path;

  // all names under the folder (all full paths)
  const names = fs.readdirSync(path).map(e => `${path}/${e}`);

  const folders: string[] = names
    .filter(e => {
      return fs.lstatSync(e).isDirectory();
    });

  const files: string[] = names
    .filter(e => fs.lstatSync(e).isFile());

  // @base case. no folder any more
  if (folders.length === 0) {
    const thisTree: Partial<FolderTree> = {
      _kind: "FolderTree",
      folderName: path,
      parentFolder: null,
    };
    thisTree.files = files.map(e => <FileIdentity>{
      filename: e,
      parentFolder: thisTree,
    });
    return <FolderTree>thisTree;
  };

  // @inductive steps
  const thisTree: Partial<FolderTree> = {
    _kind: "FolderTree",
    folderName: path,
    parentFolder: null,
  };
  thisTree.files = files.map(e => <FileIdentity>{
    _kind: "FileIdentity",
    filename: e,
    parentFolder: thisTree,
  });
  thisTree.path = folders.map(e => <FolderTree>{
    ...traverseDir_(mkPath(e)),
    _kind: "FolderTree",
    parentFolder: thisTree,
  })
  return <FolderTree>thisTree;
}


/**
 * Diff two tree, return a pair of marked trees.
 *
 * Turn both trees into list, mark everything in the from list.
 * Rebuild a new tree with all nodes contained. If there is a duplicate node, use
 * the marked version.
 * Two nodes are duplicated if they have the same (filename / foldername)
 *
 * @param a FolderTree.
 * @param a FolderTree.
 * @return A tree with nodes of both trees. If a node is marked means it exists only
 *         in the from tree but not on to tree.
 */

export function folderTreeDiff(from: FolderTree, to: FolderTree) {
  // pool with all nodes from both trees.
  let treePool: Node[] = [];
  const root = to;

  folderTreeVisitor(from, node => {
    node.tag = true;
    treePool.push(node);
  });

  folderTreeVisitor(to, node => {
    treePool.push(node);
  });

  // get rid of two root paths.
  treePool = treePool.filter(e => e.parentFolder !== null);


  console.log(treePool);
}


/**
 * Build FolderTree from a list of nodes. This is used to merge trees.
 * If there is only one root node, or several root nodes with the same
 * identity, the final tree will use it as the common root node.
 * If there are several different root nodes, it will create a new root
 * node.
 * @param trees: A list of nodes;
 * @return a new folder tree.
 */
function buildFolderTreeFromList(trees: Node[]): FolderTree {
  type Partition = [FolderTree[], Node[]];
  const [rootCandiates, others] =
    trees.reduce<Partition>(([rootCandiates, others], v) => {
      if (v._kind === "FolderTree" && v.parentFolder === null) {
        return [[...rootCandiates, v], others];
      }
      return [rootCandiates, [...others, v]];

    }, [[], []]);

  const root = mergeRoot(<FolderTree[]>rootCandiates);

  // get the top level Leaves.
  const [topLevelFolderTrees, otherFolderTrees] = (() => {
    if (root.path !== undefined) {
      return [root.path, others];
    }
    return others.reduce<Partition>(([ls, os], v) => {
      if (v.parentFolder!.folderName === root.folderName
        && v._kind === "FolderTree") {
        return [[...ls, v], os];
      }
      return [ls, [...os, v]];
    }, [[], []])

  })();

  // @rec
  const go = (leaves: FolderTree[], others: Node[]) => {
    // @base case
    if (others.length === 0) return;
    const leavesFolderNames = leaves.map(e => e.folderName);

    // add nodes leaves path and files.
    leaves.forEach(e => {
      const [files, path] = others.reduce<[FileIdentity[], FolderTree[]]>(
        ([fs, ps], v) => {
          if (v.parentFolder?.folderName === e.folderName) {
            switch (v._kind) {
              case "FolderTree":
                return [fs, [...ps, v]];
              case "FileIdentity":
                return [[...fs, v], ps];
            }
          }
          return [fs, ps];
        }, [[], []]);
      e.files = files;
      e.path = path;
    });

    const [newLeaves, newOthers] = others.reduce<Partition>(
      ([ls, os], o): Partition => {
        if (leavesFolderNames.includes((<FolderTree>o).folderName)) {
          return [[...ls, <FolderTree>o], os];
        } else {
          return [ls, [...os, o]];
        }
      }, [[], []]);

    go(newLeaves, newOthers);
  };

  go(topLevelFolderTrees, otherFolderTrees);
  return root;
}

/**
 * Build a new root based on the root candidates list.
 * @returns either a merged single root or a new root with candidates as it's sub nodes.
 */
function mergeRoot(rootCandiates: FolderTree[]): FolderTree {
  const uniqueName = new Set(rootCandiates.map(e => {
    console.assert(e._kind === "FolderTree");
    return (<FolderTree>e).folderName;
  }));

  const mergeFiles = (list: FolderTree[]) =>
    (<FolderTree["files"]>[])?.concat(...list.map(e => (<FolderTree>e).files)
      .filter(notUndefined));

  // only one real root
  if (uniqueName.size === 1) {
    return <FolderTree>{
      _kind: "FolderTree",
      parentFolder: null,
      files: mergeFiles(rootCandiates),
    }

    // some roots needs to be merges.
  } else if (uniqueName.size < rootCandiates.length) {

    const root_ = <FolderTree>{
      _kind: "FolderTree",
      parentFolder: null,
    };

    const partitioned = rootCandiates.reduce((b, a) => {
      b.get((<FolderTree>a).folderName)?.push(<FolderTree>a);
      return b;
    }, (() => {
      const map = new Map<string, FolderTree[]>();
      uniqueName.forEach(e => {
        map.set(e, []);
      });
      return map;
    })());

    // one subtree each uniqueName.
    const path = Array.from(uniqueName).map(e => {
      const toBeMergedList = partitioned.get(e)!;
      return <FolderTree>{
        _kind: "FolderTree",
        parentFolder: root_,
        folderName: e,
        files: mergeFiles(toBeMergedList),
      }
    });

    root_.path = path;
    return root_;
  }

  // nothing to merge.
  return <FolderTree>{
    _kind: "FolderTree",
    parentFolder: null,
    path: rootCandiates,
  }
}


/**
 * FolderTree visitor. Visitor every node of the tree and perform some operation on it.
 * @param node a tree node. Normally a root.
 * @param f action perform on the node, return the new node for the rest ofthe traversal.
 */
export function folderTreeVisitor(node: FolderTree, f: (node: Node) => void): FolderTree {
  const nodeCopy = {...node};

  folderTreeVisitor_(nodeCopy, f);
  return nodeCopy;
}
export function folderTreeVisitor_(
  node: Node,
  f: (node: Node) => void) {

  // mutate the node
  f(node);

  node.visited = true;

  if (node._kind === "FolderTree") {
    const edges = [...node.path ?? [], ...node.files ?? []];
    edges.forEach(e => {
      if (!e.visited) {
        folderTreeVisitor_(e, f);
      }
    })
  }
}
