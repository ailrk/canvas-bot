import {Config} from './types';
import path from 'path';
import fs from 'fs';

export type Path = {readonly path: string}
export function mkPath(p: string): Path {
  return {
    path: path.resolve(p),
  };
}

// This is one of the major data structure for implementing new file only update,
// another one is FolderTree.
//
// To only update new files we don't have in local folder, we
// build two FolderTrees: one for files in the base directory and the other for
// files from canvas. Nodes of these two trees will have some common elements like
// filename and foldernames etc, but only canvas FolderTree will have url and id.
//
// Once we built this two trees, we can compare the differences, and mark nodes
// that doesn't exist in the local tree.
// Then we perform a data fetch based on the marked canvas folder tree.
//
// Two trees will be merged after files get download, and the result will be
// saved as snapshot.
export interface FileIdentity {
  // generated by hashing the original name.
  // once it is changed it cannot be turned back.
  readonly id?: number,

  // folder tree build from local files will not have this field.
  // tree build form canvas api or stored in snapshot.
  readonly fileUrl?: string,

  // all files have a parent
  parentFolder: FolderTree,

  // filename.
  readonly filename: string,

  // mark if the node is differed from another tree.
  tag?: true,
}


// folder tree. It's used to represent the local folder structure
// Both FolderTree and FolderTreeLeaf countes as a node of the tree.
// Each node wlll have a tag to indicate if this node diffred from another tree.
//
// Two nodes are different if either
// 1. the node doesn't exist in another tree
//    (e.g. a common parent node cannot reach the current node with the same folder name)
// 2. the node contains different files.
//    (e.g A folder tree has a different )
export type FolderTree = {

  // full path of the folder
  // for canvas FolderTree each course will has the course name as
  // a corresponding folder name.
  // Thie field workds like _kind in a tag union, it marks the identity of a node.
  readonly folderName: string,

  // only root FolderTree has null
  parentFolder: FolderTree | null,

  // node values.
  files?: FileIdentity[],

  // node path.
  path?: FolderTree[],

  // mark if the node is differed from another tree.
  tag?: true,
}


/**
 * Make folder tree of current base directory.
 * If the directory is full then use another one.
 */
export async function getLocalFolderTree(config: Config) {
  const {baseDir} = config;
  return traverseDir(baseDir);
}


export function mkParialRoot(config: Config): Partial<FolderTree> {
  return <Partial<FolderTree>> {
    folderName: config.baseDir.path,
    parentFolder: null,
  }
}

/**
 * @param folderName path of a directory.
 * @return A folder tree represent the structure of the   directory.
 *         The FolderTree will also be generate for files come from canvas.
 *         These two tree will be compared and perform new file only update.
 */

// @rec
async function traverseDir(folderName: Path): Promise<FolderTree> {return traverseDir_(folderName);}
export function traverseDir_(folderName: Path): FolderTree {

  const path = folderName.path;

  // all names under the folder (all full paths)
  const names = fs.readdirSync(path).map(e => `${path}/${e}`);

  const folders: string[] = names
    .filter(e => {
      return fs.lstatSync(e).isDirectory();
    });

  const files: string[] = names
    .filter(e => fs.lstatSync(e).isFile());

  // @base case. no folder any more
  if (folders.length === 0) {
    const thisTree: Partial<FolderTree> = {
      folderName: path,
      parentFolder: null,
    };
    thisTree.files = files.map(e => <FileIdentity>{
      filename: e,
      parentFolder: thisTree,
    });
    return <FolderTree>thisTree;
  };

  // @inductive steps
  const thisTree: Partial<FolderTree> = {
    folderName: path,
    parentFolder: null,
  };
  thisTree.files = files.map(e => <FileIdentity>{
    filename: e,
    parentFolder: thisTree,
  });
  thisTree.path = folders.map(e => <FolderTree>{
    ...traverseDir_(mkPath(e)),
    parentFolder: thisTree,
  })
  return <FolderTree>thisTree;
}


/**
 * Diff two tree, return a pair of marked trees.
 *
 * Note, if files contained in the same node of two trees are differed, there
 * sub tree can still be the same.
 * But if a path between a parent node to a child node is different
 * e.g for tree1 node a it has path (a, b), but in tree2 there is no such a path,
 * then the whole sub tree after b in tree1 should be marked.
 *
 * @param pair a pair of FolderTree to get diffed.
 * @return a pair of trees with node diff from each other tagged.
 */
// export async function markFolderTreeDiff(
//   pair: [FolderTree, FolderTree]
// ): [FolderTree, FolderTree] {

//   const [t1, t2] = pair;


// }

/**
 * Check if two nodes are the same. If not, is because of different path
 * or different file they contains.
 * Note If two nodes are different, then even their files are the same they will
 * still be marked different.
 * @return Iput FoldTree with different nodes being marked, plus the reason why it's marked.
 *
 */
async function markNodeDiff(a: FolderTree, b: FolderTree) {return markNodeDiff_(a, b);}
function markNodeDiff_(a: FolderTree, b: FolderTree): {
  a: FolderTree,
  b: FolderTree,
  reason: "differentFile" | "differentFolder" | "same"
} {

  const afilenames = a.files?.map(e => e.filename).sort();
  const bfilenames = b.files?.map(e => e.filename).sort();

  // mark node. If two node are different then all there subtree
  // and files they contain are different.
  if (a.folderName !== b.folderName) {
    return {
      a: {...a, tag: true},
      b: {...b, tag: true},
      reason: "differentFolder"
    };
  }

  // mark files
  if (afilenames === undefined || bfilenames === undefined) {
    // all files are different
    return {
      a: {
        ...a,
        files: a.files ? a.files.map(e => ({...e, tag: true})) : undefined,
      },

      b: {
        ...b,
        files: b.files ? b.files.map(e => ({...e, tag: true})) : undefined,
      },

      reason: "differentFile",
    }
  }

  // find and mark set difference between two list of FileIdentity,
  const seta = new Set(afilenames);
  const setb = new Set(bfilenames);
  const notIna = new Set([...bfilenames].filter(e => !seta.has(e)))
  const notInb = new Set([...afilenames].filter(e => !setb.has(e)));

  if (notIna.size + notInb.size > 0) {
    return {
      a: {
        ...a,
        files: a.files?.filter(e => notInb.has(e.filename))
          .map(e => ({...e, tag: true}))
      },
      b: {
        ...b,
        files: b.files?.filter(e => notInb.has(e.filename))
          .map(e => ({...e, tag: true}))
      },
      reason: "differentFile"
    }
  }

  // exactly the same node.
  return {a, b, reason: "same"};
}

/**
 * Merge FolderTree a onto FolderTree b.
 * Merging one tree to another means add nodes that been marked in the tree
 * into the other tree.
 * if two nodes are different with the reason "differentFolder", we look up there
 * paraent folder until find the same ancestor.
 *
 * @param from FolderTree merge from
 * @param to FolderTree merge into
 * @return  a merged folder treee
 */
// @rec
export async function mergeFolderTree(from: FolderTree, to: FolderTree): Promise<FolderTree> {
  return mergeFolderTree(from, to);
}
function mergeFolderTrees_(from: FolderTree, to: FolderTree) {

  // @base case
  if (from.tag) {
    //

  }
  // @inductive step

}
