import {Config} from './types';
import path from 'path';
import fs from 'fs';
import {notUndefined} from './utils';

export type Path = {readonly path: string}
export function mkPath(p: string): Path {
  return {
    path: path.resolve(p),
  };
}

// This is one of the major data structure for implementing new file only update,
// another one is FolderTree.
//
// To only update new files we don't have in local folder, we
// build two FolderTrees: one for files in the base directory and the other for
// files from canvas. Nodes of these two trees will have some common elements like
// filename and foldernames etc, but only canvas FolderTree will have url and id.
//
// Once we built this two trees, we can compare the differences, and mark nodes
// that doesn't exist in the local tree.
// Then we perform a data fetch based on the marked canvas folder tree.
//
// Two trees will be merged after files get download, and the result will be
// saved as snapshot.
interface Tagged {
  tag?: boolean;

  visited?: true;
}

export interface FileIdentity extends Tagged {
  readonly _kind: "FileIdentity",

  // generated by hashing the original name.
  // once it is changed it cannot be turned back.
  readonly id?: number,

  // folder tree build from local files will not have this field.
  // tree build form canvas api or stored in snapshot.
  readonly fileUrl?: string,

  // all files have a parent
  parentFolder: FolderTree,

  // filename.
  readonly name: string,
}


// folder tree. It's used to represent the local folder structure
// Both FolderTree and FolderTreeLeaf countes as a node of the tree.
// Each node wlll have a tag to indicate if this node diffred from another tree.
//
// Two nodes are different if either
// 1. the node doesn't exist in another tree
//    (e.g. a common parent node cannot reach the current node with the same folder name)
// 2. the node contains different files.
//    (e.g A folder tree has a different )
export type FolderTree = {
  readonly _kind: "FolderTree",

  // full path of the folder
  // for canvas FolderTree each course will has the course name as
  // a corresponding folder name.
  // Thie field workds like _kind in a tag union, it marks the identity of a node.
  readonly name: string,

  // only root FolderTree has null
  parentFolder: FolderTree | null,

  // node values.
  files?: FileIdentity[],

  // node path.
  path?: FolderTree[],

} & Tagged;

export type Node = FolderTree | FileIdentity;

/**
 * Make folder tree of current base directory.
 * If the directory is full then use another one.
 */
export async function getLocalFolderTree(config: Config) {
  const {baseDir} = config;
  return traverseDir(baseDir);
}


export function mkParialRoot(config: Config): Partial<FolderTree> {
  console.log(config);
  return <Partial<FolderTree>>{
    _kind: "FolderTree",
    name: config.baseDir.path,
    parentFolder: null,
  }
}

/**
 * @param folderName path of a directory.
 * @return A folder tree represent the structure of the   directory.
 *         The FolderTree will also be generate for files come from canvas.
 *         These two tree will be compared and perform new file only update.
 */

// @rec
async function traverseDir(folderName: Path): Promise<FolderTree> {return traverseDir_(folderName);}
export function traverseDir_(folderName: Path): FolderTree {

  const path = folderName.path;

  // all names under the folder (all full paths)
  const names = fs.readdirSync(path).map(e => `${path}/${e}`);

  const folders: string[] = names
    .filter(e => {
      return fs.lstatSync(e).isDirectory();
    });

  const files: string[] = names
    .filter(e => fs.lstatSync(e).isFile());

  // @base case. no folder any more
  if (folders.length === 0) {
    const thisTree: Partial<FolderTree> = {
      _kind: "FolderTree",
      name: path,
      parentFolder: null,
    };
    thisTree.files = files.map(e => <FileIdentity>{
      name: e,
      parentFolder: thisTree,
    });
    return <FolderTree>thisTree;
  };

  // @inductive steps
  const thisTree: Partial<FolderTree> = {
    _kind: "FolderTree",
    name: path,
    parentFolder: null,
  };
  thisTree.files = files.map(e => <FileIdentity>{
    _kind: "FileIdentity",
    name: e,
    parentFolder: thisTree,
  });
  thisTree.path = folders.map(e => <FolderTree>{
    ...traverseDir_(mkPath(e)),
    _kind: "FolderTree",
    parentFolder: thisTree,
  })
  return <FolderTree>thisTree;
}


/**
 * Diff two tree, return a pair of marked trees.
 *
 * Turn both trees into list, mark everything in the from list.
 * Rebuild a new tree with all nodes contained. If there is a duplicate node, use
 * the marked version.
 * Two nodes are duplicated if they have the same (filename / foldername)
 *
 * @param a FolderTree.
 * @param a FolderTree.
 * @return A tree with nodes of both trees. If a node is marked means it exists only
 *         in the from tree but not on to tree.
 */

export function folderTreeDiff(from: FolderTree, to: FolderTree) {
  // pool with all nodes from both trees.
  let treePool: Node[] = [];
  const root = to;

  folderTreeVisitor(from, node => {
    node.tag = true;
    treePool.push(node);
  });

  folderTreeVisitor(to, node => {
    treePool.push(node);
  });

  // get rid of two root paths.
  treePool = treePool.filter(e => e.parentFolder !== null);

  const mergedTree = buildFolderTreeFromList(treePool);



  console.log(treePool);
}


/**
 * Build FolderTree from a list of nodes. This is used to merge trees.
 * If there is only one root node, or several root nodes with the same
 * identity, the final tree will use it as the common root node.
 * If there are several different root nodes, it will create a new root
 * node.
 * @param trees: A list of nodes;
 * @return a new folder tree.
 */
function buildFolderTreeFromList(trees: Node[]): FolderTree {
  type Partition = [FolderTree[], Node[]];
  const [rootCandiates, others] =
    trees.reduce<Partition>(([rootCandiates, others], v) => {
      if (v._kind === "FolderTree" && v.parentFolder === null) {
        return [[...rootCandiates, v], others];
      }
      return [rootCandiates, [...others, v]];

    }, [[], []]);

  const root = mergeRoot(<FolderTree[]>rootCandiates);

  // get the top level Leaves.
  const [topLevelFolderTrees, otherFolderTrees] = <Partition>(() => {
    if (root.path !== undefined) {
      return [root.path, others];
    }
    return others.reduce<[FolderTree[], Node[]]>(([ls, os], v) => {
      if (v.parentFolder!.name === root.name
        && v._kind === "FolderTree") {
        return [[...ls, v], os];
      }
      return [ls, [...os, v]];
    }, [[], []])
  })();

  // @rec
  const go = (leaves: FolderTree[], others: Node[]) => {
    // @base case
    if (others.length === 0) return;
    const leavesFolderNames = leaves.map(e => e.name);

    // add nodes leaves path and files.
    leaves.forEach(e => {
      const [files, path] = others.reduce<[FileIdentity[], FolderTree[]]>(
        ([fs, ps], v) => {
          if (v.parentFolder?.name === e.name) {
            switch (v._kind) {
              case "FolderTree":
                return [fs, [...ps, v]];
              case "FileIdentity":
                return [[...fs, v], ps];
            }
          }
          return [fs, ps];
        }, [[], []]);
      e.files = files;
      e.path = path;
    });

    const [newLeaves, newOthers] = others.reduce<Partition>(
      ([ls, os], o): Partition => {
        if (leavesFolderNames.includes((<FolderTree>o).name)) {
          return [[...ls, <FolderTree>o], os];
        } else {
          return [ls, [...os, o]];
        }
      }, [[], []]);

    go(newLeaves, newOthers);
  };

  go(topLevelFolderTrees, otherFolderTrees);
  return root;
}

/**
 * Build a new root based on the root candidates list.
 * @returns either a merged single root or a new root with candidates as it's sub nodes.
 */
function mergeRoot(rootCandiates: FolderTree[]): FolderTree {
  const mergedCandidates = mergeNode(rootCandiates);
  if (mergedCandidates.length === 1) {
    return mergedCandidates[0];
  }

  const root = <FolderTree>{
    _kind: "FolderTree",
    parentFolder: null,
  };

  root.path = mergedCandidates;
  mergedCandidates.forEach(e => {
    e.parentFolder = root;
  })
  return root;
};


/**
 * Merge nodes with the same identity from a FolderTree list.
 * If a merge happen between a marked and a unmarked node, leave the tag.
 * @return List of merged FolderTrees with no duplicated identity.
 */
function mergeNode(treeList: FolderTree[]): FolderTree[] {

  const uniqueFolderName = new Set(treeList
    .filter(e => e._kind === "FolderTree")
    .map(e => e.name));

  // everything merge into one node, their files should be shared.
  if (uniqueFolderName.size === 1) {
    return [<FolderTree>{
      _kind: "FolderTree",
      parentFolder: null,
      files: mergeFiles(treeList),
    }]

    // some needs to be merges.
  } else if (uniqueFolderName.size < treeList.length) {

    const root_ = <FolderTree>{
      _kind: "FolderTree",
      parentFolder: null,
    };

    const partitioned = partitionUnique(treeList);

    // one subtree each uniqueName.
    const path = Array.from(uniqueFolderName).map(e => {
      const toBeMergedList = partitioned.get(e)!;
      return <FolderTree>{
        _kind: "FolderTree",
        parentFolder: root_,
        name: e,
        files: mergeFiles(toBeMergedList),
      }
    });

    return path;
  }

  // nothing to merge.
  return treeList;
}

/**
 * merge files of FolderTrees with the same identity.
 * if there are duplicated files, remove the tag.
 */
function mergeFiles(folderTreesTobeMerged: FolderTree[]) {
  const allFiles = (<FolderTree["files"]>[])?.concat(
    ...folderTreesTobeMerged.map(e => e.files)
      .filter(notUndefined));
  // not files
  if (allFiles === undefined) return undefined;
  const partitionedMap = partitionUnique(allFiles);
  Array.from(partitionedMap.keys()).reduce<FileIdentity[]>((list, key) => {
    const partition = partitionedMap.get(key)!;
    return [...list, partition.reduce<FileIdentity>((b, a) => {
      if (!a.tag || !b.tag) {
        // duplcate file, removethe tag.
        return {...a, tag: false}
      }
      // all other cases, keep the tag.
      return {...a, tag: true}
    }, partition[0])]
  }, []);
}


/**
 * Partition elements with the same name into one list.
 */
function partitionUnique<T extends {name: string}>(list: T[]) {
  const uniqueNames = new Set(list.map(e => e.name));
  const partitionedMap = list.reduce((b, a) => {
    b.get(a.name)?.push(a);
    return b;
  }, (() => {
    const map = new Map<string, T[]>();
    uniqueNames.forEach(e => {map.set(e, []);});
    return map;
  })());

  return partitionedMap;
}


/**
 * FolderTree visitor. Visitor every node of the tree and perform some operation on it.
 * @param node a tree node. Normally a root.
 * @param f action perform on the node, return the new node for the rest ofthe traversal.
 */
export function folderTreeVisitor(node: FolderTree, f: (node: Node) => void): FolderTree {
  const nodeCopy = {...node};

  folderTreeVisitor_(nodeCopy, f);
  return nodeCopy;
}
export function folderTreeVisitor_(
  node: Node,
  f: (node: Node) => void) {
  // mutate the node
  f(node);

  node.visited = true;

  if (node._kind === "FolderTree") {
    const edges = [...node.path ?? [], ...node.files ?? []];
    edges.forEach(e => {
      if (!e.visited) {
        folderTreeVisitor_(e, f);
      }
    })
  }
}
